<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[默默的博客]]></title>
  <subtitle><![CDATA[快乐的逗比程序员]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-11-28T15:05:18.375Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[默默]]></name>
    <email><![CDATA[864202532@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[MD5浅谈]]></title>
    <link href="http://yoursite.com/2015/11/28/MD5-encryption/"/>
    <id>http://yoursite.com/2015/11/28/MD5-encryption/</id>
    <published>2015-11-28T14:00:08.000Z</published>
    <updated>2015-11-28T15:05:18.375Z</updated>
    <content type="html"><![CDATA[<p>　　message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它→信息-摘要算法。白话白话：md5，其实就是一中算法。可以将一个字符串，或文件，或压缩包，执行md5后，就可以生成一个固定长度为128bit的串。这个串，基本上是唯一的（因为一个原始数据，只对应一个md5值；但是一个md5值，可能对应多个原始数据。所有不是绝对唯一的。因此也不能作为数据库的主键）。并且md5是不可逆的，也就是没有对应的算法，从生产的md5值逆向得到原始数据（暴力破解另当别论）。<br><a id="more"></a></p>
<h3 id="1、MD5的实现">1、MD5的实现</h3><p>　　其实实现MD5的原理其实很简单，就是将要进行MD5处理的内容转换成二进制，然后获取低八位并转换成十六进制就完成了，具体代码如下：</p>
<pre><code><span class="keyword">try</span> {
        MessageDigest instance = MessageDigest.getInstance(<span class="string">"MD5"</span>);<span class="comment">// 获取MD5算法对象</span>
        <span class="built_in">byte</span>[] digest = instance.digest(password.getBytes());<span class="comment">// 对字符串加密,返回字节数组，password.getBytes()就是要进行MD5处理的内容</span>

        StringBuffer sb = <span class="keyword">new</span> StringBuffer();
        <span class="keyword">for</span> (<span class="built_in">byte</span> b : digest) {
            <span class="built_in">int</span> i = b &amp; <span class="number">0xff</span>;<span class="comment">// 获取字节的低八位有效值</span>
            <span class="keyword">String</span> hexString = Integer.toHexString(i);<span class="comment">// 将整数转为16进制</span>
            <span class="comment">// System.out.println(hexString);</span>

            <span class="keyword">if</span> (hexString.length() &lt; <span class="number">2</span>) {
                hexString = <span class="string">"0"</span> + hexString;<span class="comment">// 如果是1位的话,补0</span>
            }

            sb.<span class="built_in">append</span>(hexString);<span class="comment">//生成MD5码</span>
        }

        System.out.<span class="built_in">println</span>(<span class="string">"md5:"</span> + sb.toString());
        System.out.<span class="built_in">println</span>(<span class="string">"md5 length:"</span> + sb.toString().length());<span class="comment">//Md5都是32位</span>

    } <span class="keyword">catch</span> (NoSuchAlgorithmException e) {
        e.printStackTrace();
        <span class="comment">// 没有该算法时,抛出异常, 不会走到这里</span>
    }
</code></pre><h3 id="2、MD5加盐处理">2、MD5加盐处理</h3><p>　　通过上面的代码我们就可以进行MD5处理了，但是由于MD5还是可以破解的，并且一个MD5值可能对应多个原始数据，因此当有人破解一个MD5值时，会把相同MD5值得所有原始内容获取到。因此在进行MD5处理时会进行”加盐处理”，具体来说就是在原有材料（用户自定义密码）中加入其它成分（一般是用户自有且不变的因素），以此来增加系统复杂度。当这种盐和用户密码相结合后，再通过摘要处理，就能得到隐蔽性更强的摘要值。代码如下：</p>
<pre><code>byte<span class="string">[]</span> digest = instance.digest((username+password).getBytes());//  这里的username就是<span class="string">"盐"</span>，这样就更加不易破解
</code></pre><h3 id="3、其他">3、其他</h3><p>　　如果觉得一次MD5处理不够的话，可以将得到的MD5值再次进行处理，这样就能得到隐蔽性更强的MD5值。<br>　　<strong> 如有不正之处，请指出，谢谢。 </strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它→信息-摘要算法。白话白话：md5，其实就是一中算法。可以将一个字符串，或文件，或压缩包，执行md5后，就可以生成一个固定长度为128bit的串。这个串，基本上是唯一的（因为一个原始数据，只对应一个md5值；但是一个md5值，可能对应多个原始数据。所有不是绝对唯一的。因此也不能作为数据库的主键）。并且md5是不可逆的，也就是没有对应的算法，从生产的md5值逆向得到原始数据（暴力破解另当别论）。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="MD5" scheme="http://yoursite.com/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ListView下拉刷新跟上拉加载的实现]]></title>
    <link href="http://yoursite.com/2015/11/28/listview-refresh/"/>
    <id>http://yoursite.com/2015/11/28/listview-refresh/</id>
    <published>2015-11-28T06:18:02.000Z</published>
    <updated>2015-11-28T06:19:24.175Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="ListView下拉刷新跟上拉加载" scheme="http://yoursite.com/tags/ListView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E8%B7%9F%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xutils3上传图片]]></title>
    <link href="http://yoursite.com/2015/11/27/xutils3/"/>
    <id>http://yoursite.com/2015/11/27/xutils3/</id>
    <published>2015-11-27T13:32:59.000Z</published>
    <updated>2015-11-28T06:03:08.856Z</updated>
    <content type="html"><![CDATA[<p>　　xutils是国内wyoufif大神写的一个牛逼的开源库，功能挺全面的（单图上传、批量上传（图片）文件、加载网路图片等）。但是xutils以前的版本是基于httpclient的，者本来对于android没什么影响的。但是谷歌偏偏在android6.0以后的版本删除了httpClient，这就让我们无法正确的使用xutils了，于是xutils的作者wyoufif在前不久对对xutils版本进行大量重构，从而推出xutils3.x版本。<a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="external">xutils3详情查看</a><br><a id="more"></a></p>
<h3 id="1、xutils3简介">1、xutils3简介</h3><p>　　xutils3是作者wyoufif为了适应android6.0而对推出的新的版本。由于xutils3是基于URLConnection的，因此改动比较大，而需要升级版本的可能有些麻烦。<a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="external">详情查看</a>。由于我主要使用了上传文件模块，因此本篇文章我就主要介绍上传文件，其他模块有时间在介绍。</p>
<h3 id="2、xutils3上传单个文件（图片）">2、xutils3上传单个文件（图片）</h3><p>　　首先要使用xutils3的话，需要现在application里面进行初始化，否则会报<strong> 空指针异常 </strong>，初始化代码如下：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Application</span> {</span>
<span class="annotation">@Override</span>
public void onCreate() {
    <span class="keyword">super</span>.onCreate();
    <span class="comment">//初始化xutils3</span>
    x.<span class="type">Ext</span>.init(<span class="keyword">this</span>);
    x.<span class="type">Ext</span>.setDebug(<span class="literal">true</span>); <span class="comment">// 是否输出debug日志，这句代码可以不要</span>
    }
}
</code></pre><p>　　这样我们就能开始使用xutils3，下面就可以开始实现上传单个图片。其实在xutils3.x里面上传图片很简单，就是将通过路径找到文件，然后通过xutils3封装的类传递过去进行了。下面让我们来看单图上传关键代码：</p>
<pre><code><span class="comment">//这里的URLUtils.UPLOAD_IMG就是我们要访问的路径</span>
RequestParams <span class="keyword">params</span> = <span class="keyword">new</span> RequestParams(URLUtils.UPLOAD_IMG);
<span class="comment">//设为true就是以表单形式上传，否则上传原始文件流</span>
<span class="keyword">params</span>.setMultipart(<span class="keyword">true</span>);
<span class="comment">//下面就是请求网络时传递的参数</span>
<span class="comment">//params.addQueryStringParameter();</span>
<span class="keyword">params</span>.addBodyParameter(<span class="string">"photo"</span>, <span class="number">1</span> + <span class="string">""</span>);
<span class="keyword">params</span>.addBodyParameter(<span class="string">"uid"</span>, SharedPreferencesUtils.getString(ClipActivity.<span class="keyword">this</span>, <span class="string">"login_id"</span>));
<span class="comment">//这里的第一个字段是随便写的，第二个参数是要传递的图盘或者文件，第三个参数是这个图片或者文件的后缀名（由于图片有后缀名因此就传为空）</span>
<span class="keyword">params</span>.addBodyParameter(<span class="string">"file"</span>, <span class="keyword">new</span> File(path), <span class="keyword">null</span>);
</code></pre><h3 id="3、xutils3多图上传">3、xutils3多图上传</h3><p>　　在上面我们实现了单图上传，那么多图上传呢？就更简单了，再接再单图上传里面加个for循环就搞定。下面我们来看代码：</p>
<pre><code>RequestParams <span class="keyword">params</span> = <span class="keyword">new</span> RequestParams(URLUtils.TEST_PAGER_UPLOAD);
<span class="keyword">params</span>.setMultipart(<span class="keyword">true</span>);
<span class="keyword">params</span>.addQueryStringParameter(<span class="string">"uid"</span>, SharedPreferencesUtils.getString(context, <span class="string">"login_id"</span>));
<span class="keyword">params</span>.addQueryStringParameter(<span class="string">"tid"</span>, id);
<span class="keyword">params</span>.addQueryStringParameter(<span class="string">"title"</span>, <span class="string">"试卷111"</span>);
<span class="comment">//我这里限制的最多只能上传9张图片</span>
<span class="keyword">if</span> (num &lt; <span class="number">10</span>) {
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) {
<span class="comment">//通过路径生成文件</span>
File file = <span class="keyword">new</span> File(Bimp.tempSelectBitmap.<span class="keyword">get</span>(i).getPath_absolute());
<span class="comment">//这里的第一个参数file是随便写的，第二个则是要上传的文件，第三个怎是文件的后缀名，当有后缀名时为空</span>
<span class="keyword">params</span>.addBodyParameter(<span class="string">"file"</span> + i, file, <span class="keyword">null</span>);
    }
}
</code></pre><h3 id="4、其他">4、其他</h3><p>　　上面的代码就是我们通过xutils3来实现的方法。当然我们只是将这些参数传递到RequestParams这个实体内，然后通过发送请求就可以了。当然我们还可以对xutils3进一步封装，具体请看我的另外一篇博客<a href="/2015/11/18/volley/">Volley框架的使用</a>。上面代码经过了我的测试的。当然如果有错误之处还请读者指出来，谢谢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　xutils是国内wyoufif大神写的一个牛逼的开源库，功能挺全面的（单图上传、批量上传（图片）文件、加载网路图片等）。但是xutils以前的版本是基于httpclient的，者本来对于android没什么影响的。但是谷歌偏偏在android6.0以后的版本删除了httpClient，这就让我们无法正确的使用xutils了，于是xutils的作者wyoufif在前不久对对xutils版本进行大量重构，从而推出xutils3.x版本。<a href="https://github.com/wyouflf/xUtils3">xutils3详情查看</a><br>]]>
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="xutils3" scheme="http://yoursite.com/tags/xutils3/"/>
    
      <category term="上传图片" scheme="http://yoursite.com/tags/%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[21岁生日]]></title>
    <link href="http://yoursite.com/2015/11/22/twenty_one_birthday/"/>
    <id>http://yoursite.com/2015/11/22/twenty_one_birthday/</id>
    <published>2015-11-21T16:00:00.000Z</published>
    <updated>2015-11-14T13:49:32.331Z</updated>
    <content type="html"><![CDATA[<p>暂无<br><a id="more"></a><br>暂无</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>暂无<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Volley框架的使用]]></title>
    <link href="http://yoursite.com/2015/11/18/volley/"/>
    <id>http://yoursite.com/2015/11/18/volley/</id>
    <published>2015-11-18T15:35:28.000Z</published>
    <updated>2015-11-27T13:39:29.520Z</updated>
    <content type="html"><![CDATA[<p>　　Volley是谷歌在2013年IO大会上发布的能使网络通信更快，更简单，更健壮的android平台网络通信库，特别适合数据量不大但是通信频繁的场景。但是如果对于大数据（large payloads ），流媒体等就有些不实用，望读者能够正确的使用Volley.<br>　　<img src="http://7xo589.com1.z0.glb.clouddn.com/20130702124537953.png" alt=""><br><a id="more"></a></p>
<h3 id="1、Volley引入背景">1、Volley引入背景</h3><p>　　在android中，网络请求只有HttpURLConnection（Http协议）跟HTTPClient（Apache）两种最原生的请求方式。但是由于请求非常频繁且使用原始的方法进行网络请求非常麻烦，所有就有一些大神对这两种方式进行了封装，从而诞生可一些如xutils（xutils3支持6.0）、okHttp、AsyncHttpClient等一些开源库。但是这些开源库有一定的局限性并且包含的东西比较多（我个人观点）所有在网络请求频繁的应用场景就不是很好的适应，并且健壮性稍差一点。因此谷歌就在2013年IO大会上推出Volley开源库（由于是官方推出的，所有我就喜欢用Volley）来更好、更快的来实现网络请求。</p>
<h3 id="2、Volley功能简介">2、Volley功能简介</h3><p>　　简单的来讲，Volley提供了如下功能：</p>
<blockquote>
<p>封装了的异步的RESTful 请求API；<br>一个优雅和稳健的请求队列；<br>一个可扩展的架构，它使开发人员能够实现自定义的请求和响应处理机制；<br>能够使用外部HTTP Client库；<br>缓存策略；<br>自定义的网络图像加载视图（NetworkImageView，ImageLoader等)；</p>
</blockquote>
<p>　　由于我使用Volley最多是进行网络请求获取数据，因此此篇博客也主要是讲Volley通过get或者post从服务器上获取数据。那么首先讲通过post来从服务器上获取数据</p>
<h3 id="3、Volley请求队列的创建">3、Volley请求队列的创建</h3><p>　　由于Volley的所有请求都放在一个队列，然后进行处理。因此我们就需要创建一个消息队列（理论上这个消息队列是在任何地方都可以创建的，但是建议在application里面创建），代码如下：</p>
<pre><code>equestQueue mRequestQueue = Volley.newRequestQueue(<span class="keyword">this</span>); <span class="regexp">//</span> <span class="string">'this'</span> <span class="keyword">is</span> Context
</code></pre><p>　　如果在application里面的话：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Application</span> {</span>

<span class="comment">// 请求网络队列</span>
<span class="keyword">private</span> static <span class="type">RequestQueue</span> requestQueue;

<span class="annotation">@Override</span>
public void onCreate() {
    <span class="keyword">super</span>.onCreate();
    requestQueue = <span class="type">Volley</span>.newRequestQueue(getApplicationContext());
}

public static <span class="type">RequestQueue</span> getHttpVolley() {
    <span class="keyword">return</span> requestQueue;
}
</code></pre><p>　　这样我们就把Volley的请求队列创建好了。</p>
<h3 id="4、Volley网络请求">4、Volley网络请求</h3><p>　　下面我们就可以进行网络请求数据啦，首先我们先来看post请求来进行网络请求的代码（至于为什么是先看post，是因为post相对于get请求只是稍微难一点）：</p>
<pre><code>StringRequest stringRequest = <span class="literal">new</span> StringRequest(Request<span class="built_in">.</span>Method<span class="built_in">.</span>POST,httpurl,
<span class="literal">new</span> Response<span class="built_in">.</span>Listener&lt;<span class="built_in">String</span>&gt;() {
    @Override
    <span class="keyword">public</span> <span class="literal">void</span> onResponse(<span class="built_in">String</span> response) {
        <span class="keyword">Log</span><span class="built_in">.</span>d(<span class="built_in">TAG</span>, <span class="string">"response -&gt; "</span> + response);
    }
}, <span class="literal">new</span> Response<span class="built_in">.</span>ErrorListener() {
    @Override
    <span class="keyword">public</span> <span class="literal">void</span> onErrorResponse(VolleyErr<span class="subst">or</span> err<span class="subst">or</span>) {
        <span class="keyword">Log</span><span class="built_in">.</span>e(<span class="built_in">TAG</span>, err<span class="subst">or</span><span class="built_in">.</span>getMessage(), err<span class="subst">or</span>);
    }
}) {

@Override
<span class="keyword">protected</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; getParams() {
    <span class="comment">//在这里设置需要post的参数</span>
          <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();  
        <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"name1"</span>, <span class="string">"value1"</span>);  
        <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"name2"</span>, <span class="string">"value2"</span>);  
      <span class="keyword">return</span> <span class="keyword">params</span>;
}
<span class="comment">//将当前请求进行标记，方便管理</span>
stringRequest<span class="built_in">.</span>setTag(<span class="built_in">tag</span>);
<span class="comment">//将stringRequest添加到Volley的请求队列</span>
requestQueue<span class="built_in">.</span>add(stringRequest);
<span class="comment">//开始进行网络请求</span>
requestQueue<span class="built_in">.</span>start();
</code></pre><p>　　这样我们就能从服务器上请求到数据了。那我就先来解释一下代码。这里的<strong> StringRequest </strong>类是表示服务器返回的数据是String类型。而如果服务器返回的数据是Json对象或者json数组的话，用<strong> StringRequest </strong>则稍稍麻烦。因此Volley就给我们提供了直接返回json对象或者数据的方法，如下：</p>
<blockquote>
<p>JsonObjectRequest：返回JSON对象。<br>JsonArrayRequest：返回JsonArray。<br>StringRequest：返回String，这样可以自己处理数据，更加灵活。<br>如果返回的数据不是这三种的话我们也可以继承Request<t>自定义Request</t></p>
</blockquote>
<p>　　这样我们就可以根据后台返回的数据来采用相应的办法来解析，然后<strong> onResponse </strong>方法里面的就是当请求成功时，调用的方法。<strong> onErrorResponse </strong>则是请求失败时，调用的方法。<strong> getParams </strong>这是用post请求时需要上传的数据（以map集合的形式上传，当然也可以用ArrayMap集合）。剩下的代码已有注释就不解释啦。<br>　　上面我讲解了Volley通过post来请求数据，那么如何通过get方式来请求数据啊？这就更简单咯，直接去掉上面代码里面的getParams方法就行了。通过上述讲解我想读者都知道了Volley如何通过get或者post来请求网络了吧。</p>
<h3 id="5、Volley的封装">5、Volley的封装</h3><p>　　通过上面的代码我们就能通过Volley进行网络请求啦，但是网络访问请求过多时，我们会发现会有许多相同的代码。这样的话就需要我们来对Volley进行进一步的封装了。那么如何进行封装呢？首先我们创建一个名为<strong> VolleyInterface </strong>的抽象类，代码如下：</p>
<pre><code><span class="comment">/**
* 在这里方便对网络请求的管理，如
* 
* <span class="doctag">@author</span> Administrator
* 
*/</span>
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VolleyInterface</span> </span>{
<span class="keyword">private</span> Context context;
<span class="keyword">public</span> <span class="keyword">static</span> Listener&lt;String&gt; mListener;
<span class="keyword">public</span> <span class="keyword">static</span> ErrorListener mErrorListener;

<span class="function"><span class="keyword">public</span> <span class="title">VolleyInterface</span><span class="params">(Context context, Listener&lt;String&gt; Listener,
        ErrorListener ErrorListener)</span> </span>{
    <span class="keyword">this</span>.context = context;
    VolleyInterface.mListener = Listener;
    VolleyInterface.mErrorListener = ErrorListener;

}

<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">onMySuccess</span><span class="params">(<span class="keyword">int</span> what, String response)</span></span>;

<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">onMyError</span><span class="params">(<span class="keyword">int</span> what, VolleyError <span class="keyword">error</span>)</span></span>;

<span class="keyword">public</span> Listener&lt;String&gt; loadingListener(<span class="keyword">final</span> <span class="keyword">int</span> what) {
    mListener = <span class="keyword">new</span> Listener&lt;String&gt;() {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>{
            onMySuccess(what, response);
        }
    };
    <span class="keyword">return</span> mListener;
}

<span class="keyword">public</span> <span class="function">ErrorListener <span class="title">errorListener</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> what)</span> </span>{
    mErrorListener = <span class="keyword">new</span> ErrorListener() {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError <span class="keyword">error</span>)</span> </span>{
            onMyError(what, <span class="keyword">error</span>);
        }
    };
    <span class="keyword">return</span> mErrorListener;

}
}
</code></pre><p>　　这样我们就对Volley里面的请求成功或者失败的方法进行了一次抽取。这样我们就可以省掉一些代码了，但是如果细心的读者会发现，Volley发送请求时的代码也相同，我们是不是也可以封装啊？当然是可以的，我们首先建一个<strong> HttpUtils </strong>的工具类，然后在这个类里面写上如下代码：</p>
<pre><code><span class="keyword">private</span> StringRequest stringRequest;
<span class="keyword">public</span> <span class="literal">void</span> postVolley(int what, Context context, <span class="built_in">String</span> url, <span class="built_in">String</span> <span class="built_in">tag</span>,
        final <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="keyword">Params</span>, VolleyInterface vif) {
    MyApplication<span class="built_in">.</span>getHttpVolley()<span class="built_in">.</span>cancelAll(<span class="built_in">tag</span>);
    stringRequest = <span class="literal">new</span> StringRequest(Method<span class="built_in">.</span>POST, url,
            vif<span class="built_in">.</span>loadingListener(what), vif<span class="built_in">.</span>errorListener(what)) {
        @Override
        <span class="keyword">protected</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; getParams() throws AuthFailureErr<span class="subst">or</span> {
            <span class="keyword">return</span> <span class="keyword">Params</span>;
        }
    };
    stringRequest<span class="built_in">.</span>setTag(<span class="built_in">tag</span>);
    MyApplication<span class="built_in">.</span>getHttpVolley()<span class="built_in">.</span>add(stringRequest);
    MyApplication<span class="built_in">.</span>getHttpVolley()<span class="built_in">.</span>start();

}
</code></pre><p>　　通过上面两段代码，我们就对Volley封装好了，然后就是在需要进行网络请求的页面<strong> new </strong>一个VolletInterface对象，然后在需要进行网络请求的地方调用<strong> HttpUtils </strong>的postVolley方法就行了，这样我们对Volley的封装就完成了。是不是很简单啊，嘻嘻…</p>
<h3 id="6、注意事项">6、注意事项</h3><p>　　通过上面的代码我相信读者就能够运用Volley啦，但是在实际应用中还是有以下几点注意事项：</p>
<blockquote>
<p>1、post请求时，我们传递的参数的值不能为空否则会报空指针异常。<br>2、同时进行多次网络请求时，tag的值不能一样，否则只会执行最后的一次网络请求。<br>3、由于Volley可以与Activity的生命周期进行关联（这也是我喜欢Volley的原因），因此建议在跳转页面时，调用<code>MyApplication.getHttpVolley().cancelAll(tag);</code>取消标记为tag的网络请求。</p>
</blockquote>
<h3 id="7、其他">7、其他</h3><p>　　由于本人技术有限，因此我就只能讲解Volley通过post或者get来请求网络数据部分。也由于我写博客时间很短，写的不好的地方或者出现的问题希望读者能给我提出来，以便我更新，谢谢</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　Volley是谷歌在2013年IO大会上发布的能使网络通信更快，更简单，更健壮的android平台网络通信库，特别适合数据量不大但是通信频繁的场景。但是如果对于大数据（large payloads ），流媒体等就有些不实用，望读者能够正确的使用Volley.<br>　　<img src="http://7xo589.com1.z0.glb.clouddn.com/20130702124537953.png" alt=""><br>]]>
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="volley" scheme="http://yoursite.com/tags/volley/"/>
    
      <category term="网络请求" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo静态博客搭建教程]]></title>
    <link href="http://yoursite.com/2015/11/04/hexo/"/>
    <id>http://yoursite.com/2015/11/04/hexo/</id>
    <published>2015-11-04T15:29:44.000Z</published>
    <updated>2015-11-14T13:44:27.812Z</updated>
    <content type="html"><![CDATA[<p>　　经过接近一周的时间总算搭好属于自己的一个静态博客（可以拿来装逼，哈哈）。由于我搭建的过程中遇到了很多问题（在这里我要感谢流云跟默然两位网友的帮助），因此我就打算将自己的搭建过程分享出来，希望能帮到更多的读者（如果读者看了我的分享还没懂得话就请多百度或者给我留言）。<br><a id="more"></a></p>
<h3 id="1-下载node-js">1.下载node.js</h3><p>　　<a href="https://www.nodejs.org" target="_blank" rel="external">点击下载</a>，下载完毕直接安装即可（如果不会安装请自行百度）</p>
<h3 id="2-下载git">2.下载git</h3><p>　　这个直接百度git就可以了，网上多多（也可以在电脑管家之类的软件里面下载），下载完毕后直接安装即可。<br>　　我想上面两部作为一个程序员都是必须要求会的，如果不会的话……</p>
<h3 id="3-安装hexo">3.安装hexo</h3><p>　　下载好git以后，点击Git下的<strong> Git Bash </strong>选项，会弹出一个输入命令行的框。首先输入<strong> npm </strong>命令即可安装。然后再输入下面的两句命令行即可安装hexo完成：<br>　　<code>1、npm install hexo-cli -g</code><br>　　<code>2、npm install hexo --save</code></p>
<h3 id="4-初始化hexo">4.初始化hexo</h3><p>　　hexo安装完成后，然后就在自己电脑上新建一个文件夹（任何地方都可以）.然后鼠标右键点击新建的文件夹选择<strong> Git Bash </strong>选项然后弹出一个命令行输入框。输入下面命令行进行初始化：<br>　　<code>hexo init</code><br>　　初始化完成后会在该文件夹下生成一些列文件及文件夹（如果没有生成就代表初始化失败，具体哪些文件夹请自行百度）。<br>　　正确的生成文件夹后可以执行下面的命令行：<br>　　<code>hexo server(hexo s)</code><br>　　如果打印出下面命令行则代表运行成功，则可以在浏览器上输入<code>localhost:4000(默认端口号是4000)</code>查看默认的博客效果。<br>　　<code>hexo is running at http://0.0.0.0:4000/.</code></p>
<h3 id="5-注册github账号">5.注册github账号</h3><p>　　<a href="https://github.com/" target="_blank" rel="external">点击即可注册</a>，<strong> 注意: </strong>虽然是英文但是还是可以注册的啊。<br>　　注册成功后耐心等待10分钟左右审核时间。审核过后直接点击主页面的右下角<code>new repository</code>，创建时的name必须与用户名一致。<strong> 如lmh18841113.github.io </strong><br>　　成功后则可访问建立的静态主页了</p>
<h3 id="6-关联本地git跟远程github">6.关联本地git跟远程github</h3><p>　　至于如何让本地git跟远程github关联呢，我们采用的是SSH keys(不懂的自己去百度哈，其实这个也不需要我们懂).<br>　　那么我们如何生成SSH keys呢？我们还是打开<strong> Git Bash </strong>，然后输入：<code>ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</code>则可。<br>　　然后后面都直接选择默认（点回车就行，当然输入密码时得输入）。<strong> 注意: </strong>其实这里面可以自己选择公钥跟私钥时，我们是可以选择放在自己定义的文件夹下面。<br>　　当出现下面图片里面的命令行时则代表公钥跟私钥生成成功。<br>　　<img src="http://7xo589.com1.z0.glb.clouddn.com/lpjsl.png" alt="">　　</p>
<h3 id="7-其他">7.其他</h3><p>　　找到hexo所在文件夹，进入<strong> \source_posts </strong>到文件夹下，直接打开后缀名为.md的文件进行编辑即可（这里建议用到markdown）<br>　　由于hexo默认的主题比较丑，所有我们希望主题能好看、炫酷。所有需要我们更改主题。<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">点击更换</a>。我目前使用的主题是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">yilia</a>这位大神的所写的主题。在这里我谢谢<strong>yilia</strong>大神。<br>　　博客写完后则通过<code>hexo g</code>保存到本地，然后通过<code>hexo d</code>上传到github，然后通过github给的链接就可以访问。<strong>在这里需要注意下面几点：</strong><br>　　再向github上传时，得需要该电脑开启ssh端口（对于window来说，只有mac跟linux我就不知道了哈）。否则不会上传成功（我也没解决这个问题）。但是我用了github for window这个来上传的。可以去<a href="http://github-for-windows.en.softonic.com/" target="_blank" rel="external">github for window</a>官网下载，但是安装时需要翻墙才行。因此我又在网上找到<strong>雅然风懿</strong>分享的<a href="http://download.csdn.net/download/lyg468088/8723039?ticket=ST-65736-fzVh72OVuj7WUwM2c9w0-passport.csdn.net" target="_blank" rel="external">github for window离线安装包</a>。在这里我感谢网友雅然风懿的分享。<br>　　由于这是我第一次写博客，写的不好的地方请大家多多指教哈。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　经过接近一周的时间总算搭好属于自己的一个静态博客（可以拿来装逼，哈哈）。由于我搭建的过程中遇到了很多问题（在这里我要感谢流云跟默然两位网友的帮助），因此我就打算将自己的搭建过程分享出来，希望能帮到更多的读者（如果读者看了我的分享还没懂得话就请多百度或者给我留言）。<br>]]>
    
    </summary>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>