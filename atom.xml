<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[默默的博客]]></title>
  <subtitle><![CDATA[快乐的逗比程序员]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-12-13T02:57:11.846Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[默默]]></name>
    <email><![CDATA[864202532@qq.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[我们是否应该自己“造轮子”？]]></title>
    <link href="http://yoursite.com/2015/12/12/frame-discussion/"/>
    <id>http://yoursite.com/2015/12/12/frame-discussion/</id>
    <published>2015-12-12T02:22:54.000Z</published>
    <updated>2015-12-13T02:57:11.846Z</updated>
    <content type="html"><![CDATA[<p>　　谈谈自己对软件开发中“轮子”的一些看法<br><a id="more"></a></p>
<h2 id="什么是轮子？">什么是轮子？</h2><p>　　在开发中我们有时候会听到别人说：“我们不要重复造轮子”、“自己写轮子的话很麻烦”等，那么什么是轮子啊？其实就是我们开发过程中使用的一些开源库或者框架，比如JavaWeb中的SSH、SSH2、Hibernate以及现在很火的SpringMVC等，android中的Glide、xutils、Volley等，以及别人写的demo。</p>
<h2 id="轮子的利弊">轮子的利弊</h2><p>　　“不要重复造轮子 Stop Trying to Reinvent the Wheel”， 可能是每个程序员入行被告知的第一条准则。因为在我们入行时，别人会说，人家把轮子写好了，又很好用那么就何必自己来造轮子呢？对，这就是轮子的优点之一，简单、好用，能使很多人少写很多代码就能达到相同的效果。还有“轮子”将一些复杂的功能进行封装，让一些新手能够实现一些较复杂的功能。但是如果我们只是使用轮子，不去了解其中的原理。就会让我们成为轮子的奴隶，离开轮子后我们什么都不会，对自己百害而无一利。总而言之我们使用轮子是既有利又有害的，利是能够提升开发效率，将一些开发门槛降低了，并且方便好用；害的是容易使我们过度依赖于轮子，不去对自己技术的进行提升。</p>
<h2 id="是否该自己造轮子？">是否该自己造轮子？</h2><p>　　既然轮子的使用对技术提升不是很大，那么我们是否该自己造轮子呢？其实也不对，当我们技术不是很牛逼时最好还是使用轮子比较好，因为我们在公司开发项目时，要求的是效率，代码健壮。而自己造的轮子难免会有各种bug，到时候改的话会有很多问题，影响项目开发效率。只有我们技术牛逼时才考虑去自己造轮子。因此我建议只有我们技术牛逼时采取造轮子（因为在我看来要造轮子就要造一个好轮子）。</p>
<h2 id="我的看法">我的看法</h2><p>　　以我的开发经验来看，推荐使用一些好轮子（有api文档，demo，有一定的人使用的轮子），并且使用后还得理解轮子的代码实现及原理，但是我们还是得与轮子保持一定距离（避免过度依赖轮子）。当能力达到一定程度后就自己开始写轮子，这样才能对自己技术有很大的提升。<br>　　如有不正之处，请留言…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　谈谈自己对软件开发中“轮子”的一些看法<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android三级缓存浅谈]]></title>
    <link href="http://yoursite.com/2015/12/06/three-cache/"/>
    <id>http://yoursite.com/2015/12/06/three-cache/</id>
    <published>2015-12-06T12:39:45.000Z</published>
    <updated>2015-12-12T03:42:50.622Z</updated>
    <content type="html"><![CDATA[<p>　　在android开发中，我们在加载图片时，经常会遇到内存溢出的错误（如果使用第三方库就不会存在这种问题）。那么如何解决这样的内存溢出啊？一些大牛们就提供了三级缓存这种解决思路。<br><a id="more"></a></p>
<h3 id="1、内存溢出的原因">1、内存溢出的原因</h3><p>　　首先我们要知道，在android里面内存是一种非常重要的资源，因此每一个app就都被android分配了固定的内存，而我们在加载图片时直接加载在内存中的，当图片数量太多时，内存就会超过系统给我们这个app分配的内存。这样就出现了内存溢出。</p>
<h3 id="2、三级缓存的原理">2、三级缓存的原理</h3><p>　　通过上面我们知道了内存溢出产生的原因。那么我们如何解决这种内存溢出呢？其实在我看来有两种方法：</p>
<blockquote>
<p>1、对图片添加软引用，这是在android3.0以前的普遍解决办法。但是由于android3.0以后软引用很容易被垃圾回收机制回收掉，因此容易产生各种错误，所以目前就不推荐使用该方法(这里我也就不讲解)。<br>2、通过三级缓存来实现，这是目前主流的解决方法。也是目前推荐的解决办法（很多加载图片开源库的原理就是三级缓存，如Glide,xutils等）。</p>
</blockquote>
<p>　　然我们通过三级缓存解决内存溢出问题，那么我们就来说说什么是三级缓存。</p>
<blockquote>
<p>三级就是内存、sd卡、网络这三级，当我们加载图片时首先从网络获取图片、获取成功后我们保存到sd卡跟内存，那么我们下次在加载相同图片时就会首先从内存里面找图片，如果内存里面有，就直接加载，如果没有，我们就从sd卡里面获取，如果sd卡里面有的话，就直接加载并且保存在内存中。如果没有就从网络获取然后保存在sd卡跟内存中。这样我们实现了三级缓存。</p>
</blockquote>
<p>　　那么可能有人会问，加载到内存的图片怎么会找不到呢？这里我们就要说的我们实现三级缓存需要用到的Lru缓存。</p>
<blockquote>
<p>Lru说简单点就是一个经过特殊处理的Map集合，是怎么特殊处理的呢？首先我们给Lru分配一个内存（一般为运行内存的1/8），然后把图片放进去，如果图片的总内存小于我们分配的内存则可以继续放，但是如果超出我们分配的内存，Lru就会最后面的图片的引用变为易于回收的引用，方便回收。这里为什么是最后面啊？因为在Lru会把经常使用的图片的位置往前移。不经常使用的就只有往后排了。</p>
</blockquote>
<p>　　这就是三级缓存的原理，下面就来说说具体实现。</p>
<h3 id="3、代码实现">3、代码实现</h3><p>　　上面我们我们了解了三级缓存的原理，下面我就代码来实现，首先创建工具类</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BitmapUtils</span> {
<span class="comment">//网络获取工具类</span>
<span class="keyword">private</span> NetCacheUtils netCacheUtils;
<span class="comment">//sd卡获取工具类</span>
<span class="keyword">private</span> LocalCacheUtils localCacheUtils;
<span class="comment">//内存获取工具类</span>
<span class="keyword">private</span> MemoryCacheUtils memoryCacheUtils;

<span class="function"><span class="keyword">public</span> <span class="title">BitmapUtils</span>(<span class="params"></span>) </span>{
    memoryCacheUtils = <span class="keyword">new</span> MemoryCacheUtils();
    localCacheUtils = <span class="keyword">new</span> LocalCacheUtils();
    <span class="comment">// 之所以在这里传入两个对象是为了让这两个对象只实例化一次</span>
    netCacheUtils = <span class="keyword">new</span> NetCacheUtils(localCacheUtils, memoryCacheUtils);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span>(<span class="params">String url,ImageView imageView</span>) </span>{
    Bitmap bitmap=<span class="keyword">null</span>;
    <span class="comment">//从内存里面读取图片</span>
    bitmap=memoryCacheUtils.getBitmapToMemory(url);
    <span class="keyword">if</span>(bitmap!=<span class="keyword">null</span>){
        <span class="keyword">return</span>;
    }
    <span class="comment">//从sd卡里面读取图片</span>
    bitmap=localCacheUtils.getBitmapFromLocal(url);
    <span class="keyword">if</span>(bitmap!=<span class="keyword">null</span>){
        imageView.setImageBitmap(bitmap);
        memoryCacheUtils.setBitmapToMemory(url, bitmap);
        <span class="keyword">return</span>;
    }
    <span class="comment">//从网络读取图片</span>
    netCacheUtils.getBitmapFromNet(url, imageView);
}
}
</code></pre><p>　　然后我们首先来代码实现网络获取图片：</p>
<pre><code>public class <span class="type">NetCacheUtils</span> {
private <span class="type">LocalCacheUtils</span> localCacheUtils;
private <span class="type">MemoryCacheUtils</span> memoryCacheUtils;

public <span class="type">NetCacheUtils</span>(<span class="type">LocalCacheUtils</span> localCacheUtils,
        <span class="type">MemoryCacheUtils</span> memoryCacheUtils) {
    this.localCacheUtils = localCacheUtils;
    this.memoryCacheUtils = memoryCacheUtils;
}

public <span class="type">void</span> getBitmapFromNet(<span class="type">String</span> url, <span class="type">ImageView</span> imageView) {
    new <span class="type">BitmapTask</span>().execute(url, imageView);
}

/**
 * <span class="type">Handler</span>和线程池的封装
 * 
 * 第一个泛型: 参数类型 第二个泛型: 更新进度的泛型, 第三个泛型是onPostExecute的返回结果
 * 
 * @author <span class="type">Kevin</span>
 * 
 */
private class <span class="type">BitmapTask</span> extends <span class="type">AsyncTask</span>&lt;<span class="type">Object</span>, <span class="type">Void</span>, <span class="type">Bitmap</span>&gt; {

    private <span class="type">String</span> url;
    private <span class="type">ImageView</span> imageView;

    // 耗时操作
    @<span class="type">Override</span>
    protected <span class="type">Bitmap</span> doInBackground(<span class="type">Object</span>... params) {
        url = (<span class="type">String</span>) params[<span class="number">0</span>];
        imageView = (<span class="type">ImageView</span>) params[<span class="number">1</span>];
        //将url与imageView进行绑定
        imageView.setTag(url);
        <span class="keyword">return</span> downloadBitmap(url);
    }

    // 更新<span class="type">UI</span>
    @<span class="type">Override</span>
    protected <span class="type">void</span> onPostExecute(<span class="type">Bitmap</span> <span class="literal">result</span>) {
        // super.onPostExecute(<span class="literal">result</span>);
        <span class="keyword">if</span> (<span class="literal">result</span> != null) {
            <span class="type">String</span> str = (<span class="type">String</span>) imageView.getTag();
            <span class="keyword">if</span> (str.equals(url)) {//确保将图片正确与imageView相对应
                imageView.setImageBitmap(<span class="literal">result</span>);
                localCacheUtils.setBitmapFromLocal(url, <span class="literal">result</span>);
                memoryCacheUtils.setBitmapToMemory(url, <span class="literal">result</span>);
            }
        }
    }

    // 进度更新
    @<span class="type">Override</span>
    protected <span class="type">void</span> onProgressUpdate(<span class="type">Void</span>... values) {
        // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub
        super.onProgressUpdate(values);
    }

}

// 根据图片路径来下载图片
private <span class="type">Bitmap</span> downloadBitmap(<span class="type">String</span> url) {
    <span class="type">HttpURLConnection</span> conn = null;
    <span class="keyword">try</span> {
        conn = (<span class="type">HttpURLConnection</span>) new <span class="type">URL</span>(url).openConnection();
        // 设置连接时间（大于<span class="number">5</span>秒则超时）
        conn.setConnectTimeout(<span class="number">5000</span>);
        // 设置响应时间，大于<span class="number">5000</span>秒也超时
        conn.setReadTimeout(<span class="number">5000</span>);
        // 设置请求方式为get
        conn.setRequestMethod(<span class="string">"GET"</span>);
        // 不允许使用缓存
        conn.setUseCaches(<span class="literal">false</span>);
        conn.connect();
        // 获得响应码
        <span class="type">int</span> code = conn.getResponseCode();
        <span class="keyword">if</span> (code == <span class="number">200</span>) {
            <span class="type">InputStream</span> inputStream = conn.getInputStream();
            <span class="type">Bitmap</span> bitmap = <span class="type">BitmapFactory</span>.decodeStream(inputStream);
            <span class="keyword">return</span> bitmap;
        }
    } catch (<span class="type">Exception</span> e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        // 关闭连接
        conn.disconnect();
    }

    <span class="keyword">return</span> null;
}
</code></pre><p>}</p>
<p>　　通过上面代码我们就实现了网络获取图片，这里我采用的是AsyncTask来进行异步操作，HttpURLConnection来下载的网络图片，然后我们来实现sd卡加载图片</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> LocalCacheUtils {
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PATH = Environment
        .getExternalStorageDirectory().getAbsolutePath()
        + <span class="string">"/image_cache_52"</span>;

<span class="comment">//从sd卡里面读取图片</span>
<span class="keyword">public</span> Bitmap getBitmapFromLocal(String url) {
    <span class="keyword">try</span> {
        String fileName = MD5Encoder.encode(url);
        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(CACHE_PATH, fileName);
        <span class="keyword">if</span> (<span class="keyword">file</span>.exists()) {
            Bitmap bitmap = BitmapFactory.decodeStream(<span class="keyword">new</span> FileInputStream(
                    <span class="keyword">file</span>));
            <span class="keyword">return</span> bitmap;
        }
    } <span class="keyword">catch</span> (Exception e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="comment">//往sd里面写入图片</span>
<span class="keyword">public</span> <span class="keyword">void</span> setBitmapFromLocal(String url, Bitmap bitmap) {
    String fileName;
    <span class="keyword">try</span> {
        fileName = MD5Encoder.encode(url);
        <span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(CACHE_PATH, fileName);
        <span class="keyword">File</span> fileParent = <span class="keyword">file</span>.getParentFile();
        <span class="keyword">if</span> (!fileParent.exists()) {
            fileParent.mkdirs();
        }
        <span class="comment">//保存到sd卡</span>
        bitmap.compress(CompressFormat.JPEG, <span class="number">100</span>,
                <span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>));
    } <span class="keyword">catch</span> (Exception e) {
        <span class="comment">// TODO Auto-generated catch block</span>
        e.printStackTrace();
    }
}
}
</code></pre><p>　　最后我们就是来实现内存加载图片了，废话不多说，直接上代码：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MemoryCacheUtils</span> {

<span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; lruCache;
<span class="function"><span class="keyword">public</span> <span class="title">MemoryCacheUtils</span>(<span class="params"></span>)</span>{
    <span class="comment">//一般使用最大内存的1/8来进行图片缓存</span>
    <span class="keyword">long</span> maxMemory=Runtime.getRuntime().maxMemory()/<span class="number">8</span>;
    lruCache=<span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;((<span class="keyword">int</span>) maxMemory){
        @<span class="function">Override
        <span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span>(<span class="params">String key, Bitmap <span class="keyword">value</span></span>) </span>{
            <span class="comment">//获取图片的占用内存大小</span>
            <span class="keyword">int</span> size=<span class="keyword">value</span>.getRowBytes()*<span class="keyword">value</span>.getHeight();
            <span class="keyword">return</span> size;
        }
    };
}

<span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapToMemory</span>(<span class="params">String url</span>)</span>{
    <span class="keyword">return</span> lruCache.<span class="keyword">get</span>(url);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBitmapToMemory</span>(<span class="params">String url,Bitmap bitmap</span>)</span>{
    lruCache.put(url, bitmap);
}
}
</code></pre><p>　　这样我们的三级缓存就大功告成啦。哈哈哈</p>
<h3 id="4、其他">4、其他</h3><p>　　虽然上面代码实现了三级缓存，但是我还是不建议直接使用上面代码运用到项目中。因为上面代码只是实现了三级缓存的一个皮毛，还有大量细节需要处理。并且上面代码也有报内存溢出的可能，至于如何优化请看后面的博客。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　在android开发中，我们在加载图片时，经常会遇到内存溢出的错误（如果使用第三方库就不会存在这种问题）。那么如何解决这样的内存溢出啊？一些大牛们就提供了三级缓存这种解决思路。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="三级缓存" scheme="http://yoursite.com/tags/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    
      <category term="加载图片" scheme="http://yoursite.com/tags/%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android引导页的实现]]></title>
    <link href="http://yoursite.com/2015/12/02/guide-page/"/>
    <id>http://yoursite.com/2015/12/02/guide-page/</id>
    <published>2015-12-02T14:00:49.000Z</published>
    <updated>2015-12-02T14:27:34.916Z</updated>
    <content type="html"><![CDATA[<p>　　在第一次进入某些APP时，会有一个引导页面来告诉用户该怎么操作这个APP。而其中有些的引导页实现了这样一个功能，不知道有些人注意没，就是当我们手指滑动引导页时，引导页下面的小圆点也会随着手指滑动。关于这个功能我想有很多人都是用一些开源库写的（说实话，我不是很喜欢用一些开源库，虽然效率很高，但是对自己技术的提升不是很大，除非完全弄懂源码），而在这里我就教大家怎么来实现。<br><a id="more"></a></p>
<hr>
<p>　　首先我来说一下原理，其实实现是很简单的，因为引导页本身就是viewpager,所有我们只需要从后台获取到图片路径并加载到viewpager就行。至于下面的小圆点就是根据shape这个xml来实现。废话不多说直接上代码：<br>　　我们先来看xml代码：</p>
<pre><code><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
<span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>
<span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
<span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> &gt;</span>
<span class="comment">&lt;!---viewpager--&gt;</span>
<span class="tag">&lt;<span class="title">android.support.v4.view.ViewPager</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/vp_guide"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span>

<span class="tag">&lt;<span class="title">RelativeLayout</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_alignParentBottom</span>=<span class="value">"true"</span>
    <span class="attribute">android:layout_centerHorizontal</span>=<span class="value">"true"</span>
    <span class="attribute">android:layout_marginBottom</span>=<span class="value">"20dp"</span> &gt;</span>
    <span class="comment">&lt;!--装小圆点的布局--&gt;</span>
    <span class="tag">&lt;<span class="title">LinearLayout</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/ll_point_group"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span> &gt;</span>
    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
    <span class="comment">&lt;!--滑动的小圆点--&gt;</span>
    <span class="tag">&lt;<span class="title">View</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/view_red_point"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"10dp"</span>
        <span class="attribute">android:background</span>=<span class="value">"@drawable/shape_point_red"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span>
</code></pre><p></p>
<p>　　我相信上面的代码都能看懂吧，如果不懂的话…<br>　　既然布局写好了，那么就来看小圆点的绘制的代码：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">shape</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
<span class="attribute">android:shape</span>=<span class="value">"oval"</span> &gt;</span>
<span class="comment">&lt;!--android:shape="oval"就是代表绘制的是小圆点，这里也可以绘制其他图像，如圆环等--&gt;</span>
<span class="comment">&lt;!--下面表示小圆点的颜色--&gt;</span>
<span class="tag">&lt;<span class="title">solid</span> <span class="attribute">android:color</span>=<span class="value">"@android:color/darker_gray"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">shape</span>&gt;</span>
</code></pre><p>　　就这样布局文件就好了，那么就让我们来看下面的具体实现代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnPageChangeListener</span> </span>{
&lt;!--引导页图片--&gt;
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] mImageIds = <span class="keyword">new</span> <span class="keyword">int</span>[] { R.drawable.guide_1,
        R.drawable.guide_2, R.drawable.guide_3 };

<span class="keyword">private</span> ViewPager vpGuide;
<span class="keyword">private</span> ArrayList&lt;ImageView&gt; mImageViewList;

<span class="keyword">private</span> LinearLayout llPointGroup;<span class="comment">// 引导圆点的父控件</span>

<span class="keyword">private</span> <span class="keyword">int</span> mPointWidth;<span class="comment">// 圆点间的距离</span>

<span class="keyword">private</span> View viewRedPoint;<span class="comment">// 小红点</span>

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    vpGuide = (ViewPager) findViewById(R.id.vp_guide);
    llPointGroup = (LinearLayout) findViewById(R.id.ll_point_group);
    viewRedPoint = findViewById(R.id.view_red_point);
    initViews();
    vpGuide.setAdapter(<span class="keyword">new</span> GuideAdapter());
    vpGuide.setOnPageChangeListener(<span class="keyword">this</span>);
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initViews</span><span class="params">()</span> </span>{
    mImageViewList = <span class="keyword">new</span> ArrayList&lt;ImageView&gt;();

    <span class="comment">// 初始化引导页的3个页面</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mImageIds.length; i++) {
        ImageView image = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);
        image.setBackgroundResource(mImageIds[i]);<span class="comment">// 设置引导页背景</span>
        mImageViewList.add(image);
    }

    <span class="comment">// 初始化引导页的小圆点</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mImageIds.length; i++) {
        View point = <span class="keyword">new</span> View(<span class="keyword">this</span>);
        point.setBackgroundResource(R.drawable.shape_point_gray);<span class="comment">// 设置引导页默认圆点</span>

        LinearLayout.LayoutParams params = <span class="keyword">new</span> LinearLayout.LayoutParams(
                <span class="number">30</span>, <span class="number">30</span>);
        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {
            params.leftMargin = <span class="number">10</span>;<span class="comment">// 设置圆点间隔</span>
        }

        point.setLayoutParams(params);<span class="comment">// 设置圆点的大小</span>

        llPointGroup.addView(point);<span class="comment">// 将圆点添加给线性布局</span>
    }
    <span class="comment">//界面绘制是要调用measure():测量，layout():界面位置，onDraw():绘制三个方法</span>
    <span class="comment">// 得到两个小灰点之间的间距(这里拿到的是0，因为在oncreate()方法里，界面还没绘制完成)</span>
<span class="comment">//        mPointWidth = llPointGroup.getChildAt(1).getLeft()</span>
<span class="comment">//                - llPointGroup.getChildAt(0).getLeft();</span>
    <span class="comment">//获取到视图树（观察者模式）</span>
    llPointGroup.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> OnGlobalLayoutListener() {
        <span class="comment">//当调用layout()方法结束后调用此方法</span>
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>{
            <span class="comment">//已过时，</span>
            llPointGroup.getViewTreeObserver().removeGlobalOnLayoutListener(<span class="keyword">this</span>);
            <span class="comment">//最新的，但是最低兼容貌似是14</span>
            <span class="comment">//llPointGroup.getViewTreeObserver().removeOnGlobalLayoutListener(this);</span>
            mPointWidth = llPointGroup.getChildAt(<span class="number">1</span>).getLeft()
                    - llPointGroup.getChildAt(<span class="number">0</span>).getLeft();
        }
    });
}

<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">GuideAdapter</span> <span class="keyword">extends</span> <span class="title">PagerAdapter</span> </span>{

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> mImageIds.length;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isViewFromObject</span><span class="params">(View arg0, Object arg1)</span> </span>{
        <span class="keyword">return</span> arg0 == arg1;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> Object <span class="title">instantiateItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position)</span> </span>{
        container.addView(mImageViewList.get(position));
        <span class="keyword">return</span> mImageViewList.get(position);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>{
        container.removeView((View) object);
    }

}

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span>{
}

<span class="comment">// 第二个参数是viewpager滑动的百分比</span>
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset,
        <span class="keyword">int</span> positionOffsetPixels)</span> </span>{
    <span class="comment">// System.out.println("当前位置:" + position + ";百分比:" + positionOffset</span>
    <span class="comment">// + ";移动距离:" + positionOffsetPixels);</span>
    <span class="keyword">int</span> len=(<span class="keyword">int</span>) (positionOffset*mPointWidth)+position*mPointWidth;
    RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) viewRedPoint
            .getLayoutParams();<span class="comment">// 获取当前红点的布局参数</span>
    params.leftMargin = len;<span class="comment">// 设置左边距</span>

    viewRedPoint.setLayoutParams(params);<span class="comment">// 重新给小红点设置布局参数</span>
}

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span>{
}
}
</code></pre><p>　　这样就实现了引导页下面的小圆点随着手指的滑动而滑动了。由于我暂不会gif动画的制作，因此就没有效果图。有误的地方希望大家指出，谢谢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　在第一次进入某些APP时，会有一个引导页面来告诉用户该怎么操作这个APP。而其中有些的引导页实现了这样一个功能，不知道有些人注意没，就是当我们手指滑动引导页时，引导页下面的小圆点也会随着手指滑动。关于这个功能我想有很多人都是用一些开源库写的（说实话，我不是很喜欢用一些开源库，虽然效率很高，但是对自己技术的提升不是很大，除非完全弄懂源码），而在这里我就教大家怎么来实现。<br>]]>
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MD5浅谈]]></title>
    <link href="http://yoursite.com/2015/11/28/MD5-encryption/"/>
    <id>http://yoursite.com/2015/11/28/MD5-encryption/</id>
    <published>2015-11-28T14:00:08.000Z</published>
    <updated>2015-12-02T14:33:25.435Z</updated>
    <content type="html"><![CDATA[<p>　　message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它→信息-摘要算法。白话白话：md5，其实就是一中算法。可以将一个字符串，或文件，或压缩包，执行md5后，就可以生成一个固定长度为128bit的串。这个串，基本上是唯一的（因为一个原始数据，只对应一个md5值；但是一个md5值，可能对应多个原始数据。所有不是绝对唯一的。因此也不能作为数据库的主键）。并且md5是不可逆的，也就是没有对应的算法，从生产的md5值逆向得到原始数据（暴力破解另当别论）。<br><a id="more"></a></p>
<h3 id="1、MD5的实现">1、MD5的实现</h3><p>　　其实实现MD5的原理其实很简单，就是将要进行MD5处理的内容转换成二进制，然后获取低八位并转换成十六进制就完成了，具体代码如下：</p>
<pre><code><span class="keyword">try</span> {
        MessageDigest instance = MessageDigest.getInstance(<span class="string">"MD5"</span>);<span class="comment">// 获取MD5算法对象</span>
        <span class="built_in">byte</span>[] digest = instance.digest(password.getBytes());<span class="comment">// 对字符串加密,返回字节数组，password.getBytes()就是要进行MD5处理的内容</span>

        StringBuffer sb = <span class="keyword">new</span> StringBuffer();
        <span class="keyword">for</span> (<span class="built_in">byte</span> b : digest) {
            <span class="built_in">int</span> i = b &amp; <span class="number">0xff</span>;<span class="comment">// 获取字节的低八位有效值</span>
            <span class="keyword">String</span> hexString = Integer.toHexString(i);<span class="comment">// 将整数转为16进制</span>
            <span class="comment">// System.out.println(hexString);</span>

            <span class="keyword">if</span> (hexString.length() &lt; <span class="number">2</span>) {
                hexString = <span class="string">"0"</span> + hexString;<span class="comment">// 如果是1位的话,补0</span>
            }

            sb.<span class="built_in">append</span>(hexString);<span class="comment">//生成MD5码</span>
        }

        System.out.<span class="built_in">println</span>(<span class="string">"md5:"</span> + sb.toString());
        System.out.<span class="built_in">println</span>(<span class="string">"md5 length:"</span> + sb.toString().length());<span class="comment">//Md5都是32位</span>

    } <span class="keyword">catch</span> (NoSuchAlgorithmException e) {
        e.printStackTrace();
        <span class="comment">// 没有该算法时,抛出异常, 不会走到这里</span>
    }
</code></pre><h3 id="2、MD5加盐处理">2、MD5加盐处理</h3><p>　　通过上面的代码我们就可以进行MD5处理了，但是由于MD5还是可以破解的，并且一个MD5值可能对应多个原始数据，因此当有人破解一个MD5值时，会把相同MD5值得所有原始内容获取到。因此在进行MD5处理时会进行”加盐处理”，具体来说就是在原有材料（用户自定义密码）中加入其它成分（一般是用户自有且不变的因素），以此来增加系统复杂度。当这种盐和用户密码相结合后，再通过摘要处理，就能得到隐蔽性更强的摘要值。代码如下：</p>
<pre><code>byte<span class="string">[]</span> digest = instance.digest((username+password).getBytes());//  这里的username就是<span class="string">"盐"</span>，这样就更加不易破解
</code></pre><h3 id="3、其他">3、其他</h3><p>　　如果觉得一次MD5处理不够的话，可以将得到的MD5值再次进行处理，这样就能得到隐蔽性更强的MD5值。但是如果有人要查询MD5值怎么办呢？我这里给大家推荐个网站可以查询MD5值<a href="http://www.cmd5.com/" target="_blank" rel="external">http://www.cmd5.com/</a>。在这里或许有人说MD5是不可逆的，怎么还能查询？其实这个网站的原理是将MD5值存在数据库里的，然后在将你传的MD5值拿去比对从而达到对MD5的解密。<br>　　<strong> 如有不正之处，请指出，谢谢。 </strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它→信息-摘要算法。白话白话：md5，其实就是一中算法。可以将一个字符串，或文件，或压缩包，执行md5后，就可以生成一个固定长度为128bit的串。这个串，基本上是唯一的（因为一个原始数据，只对应一个md5值；但是一个md5值，可能对应多个原始数据。所有不是绝对唯一的。因此也不能作为数据库的主键）。并且md5是不可逆的，也就是没有对应的算法，从生产的md5值逆向得到原始数据（暴力破解另当别论）。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="MD5" scheme="http://yoursite.com/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ListView下拉刷新跟上拉加载的实现]]></title>
    <link href="http://yoursite.com/2015/11/28/listview-refresh/"/>
    <id>http://yoursite.com/2015/11/28/listview-refresh/</id>
    <published>2015-11-28T06:18:02.000Z</published>
    <updated>2015-12-06T12:36:41.125Z</updated>
    <content type="html"><![CDATA[<p>　　下拉刷新跟上拉加载这两个功能我相信在android开发中用的很多，毕竟这两个功能在增强用户体验，也解决了很多开发问题。但是我相信这两个功能的实现恐怕不好实现吧（针对很多新手来说），于是就有很多开源库比如<a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="external">Android-PullToRefresh</a>、谷歌自己推出的SwipeRefreshLayout等开源库。但是由于我认为自己造轮子对自己的技术提升比较好，因此我自己也写了一个针对listView的下拉刷新跟上拉加载。<br><a id="more"></a></p>
<hr>
<p>　　首先我们先来说说实现的原理，首先我们先把刷新部分的布局写好，让他通过ListView的addHeaderView(View)方法填到头部（ListView的addHeaderView(View)可以添加多个。上拉加载是用addFooterView(View)方法），然后将这个布局隐藏，随着手指的滑动二显示并且进行相应的状态变化。<br>　　上面说了实现原理，那么下面就来实现，首先我们先写好下拉刷新部分的布局refresh_header.xml：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
<span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
<span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
<span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span> &gt;</span>

<span class="tag">&lt;<span class="title">FrameLayout</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:padding</span>=<span class="value">"10dp"</span> &gt;</span>

    <span class="tag">&lt;<span class="title">ImageView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/iv_arr"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_gravity</span>=<span class="value">"center"</span>
        <span class="attribute">android:src</span>=<span class="value">"@drawable/common_listview_headview_red_arrow"</span> /&gt;</span>

    <span class="tag">&lt;<span class="title">ProgressBar</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/pb_progress"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_gravity</span>=<span class="value">"center"</span>
        <span class="attribute">android:visibility</span>=<span class="value">"invisible"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">FrameLayout</span>&gt;</span>

<span class="tag">&lt;<span class="title">LinearLayout</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_gravity</span>=<span class="value">"center"</span>
    <span class="attribute">android:gravity</span>=<span class="value">"center"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> &gt;</span>

    <span class="tag">&lt;<span class="title">TextView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_title"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:text</span>=<span class="value">"下拉刷新"</span>
        <span class="attribute">android:textColor</span>=<span class="value">"#f00"</span>
        <span class="attribute">android:textSize</span>=<span class="value">"16sp"</span> /&gt;</span>

    <span class="tag">&lt;<span class="title">TextView</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_time"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_marginTop</span>=<span class="value">"5dp"</span>
        <span class="attribute">android:text</span>=<span class="value">"最后刷新时间:2015-03-10 17:07:07"</span>
        <span class="attribute">android:textColor</span>=<span class="value">"@android:color/darker_gray"</span>
        <span class="attribute">android:textSize</span>=<span class="value">"14sp"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p></p>
<p>　　这样下拉部分的布局就写好了，然后我们再来写上拉加载的布局，创建一个名为refresh_listview_footer的上拉加载的布局文件，代码如下：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
<span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
<span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
<span class="attribute">android:gravity</span>=<span class="value">"center"</span>
<span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span> &gt;</span>

<span class="tag">&lt;<span class="title">ProgressBar</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/pb_pull_list_header"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_gravity</span>=<span class="value">"center"</span>
    <span class="attribute">android:layout_margin</span>=<span class="value">"5dp"</span>
    <span class="attribute">android:indeterminateDrawable</span>=<span class="value">"@drawable/custom_progress"</span> /&gt;</span>

<span class="tag">&lt;<span class="title">TextView</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/tv_pull_list_header_title"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:text</span>=<span class="value">"加载中..."</span>
    <span class="attribute">android:textColor</span>=<span class="value">"#ff0000"</span>
    <span class="attribute">android:textSize</span>=<span class="value">"18sp"</span> /&gt;</span>
</code></pre><p></p>
<p>　　这样我们就把布局写好了，然后我们就将布局加到ListView里面去，这里要加到ListView里面去则需要重写ListView，下面我们就来创建一个继承与ListView的RefreshListView类：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> RefreshListView extends ListView implements OnScrollListener,
    android.widget.AdapterView.OnItemClickListener {


<span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STATE_PULL_REFRESH = <span class="number">0</span>;<span class="comment">// 下拉刷新</span>
<span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STATE_RELEASE_REFRESH = <span class="number">1</span>;<span class="comment">// 松开刷新</span>
<span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> STATE_REFRESHING = <span class="number">2</span>;<span class="comment">// 正在刷新</span>

<span class="keyword">private</span> <span class="keyword">int</span> mCurrrentState = STATE_PULL_REFRESH;<span class="comment">// 当前状态</span>

<span class="keyword">private</span> TextView tvTitle;
<span class="keyword">private</span> TextView tvTime;
<span class="keyword">private</span> ImageView ivArrow;
<span class="keyword">private</span> ProgressBar pbProgress;
<span class="keyword">private</span> View mHeaderView;
<span class="keyword">private</span> <span class="keyword">int</span> startY = -<span class="number">1</span>;
<span class="keyword">private</span> <span class="keyword">int</span> mHeaderViewHeight;
<span class="keyword">private</span> RotateAnimation animUp;
<span class="keyword">private</span> RotateAnimation animDown;
<span class="keyword">private</span> View mFooterView;
<span class="keyword">private</span> <span class="keyword">int</span> mFooterViewHeight;

<span class="function"><span class="keyword">public</span> <span class="title">RefreshListView</span><span class="params">(Context context)</span> </span>{
    super(context);
    initHeaderView();
}

<span class="function"><span class="keyword">public</span> <span class="title">RefreshListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>{
    super(context, attrs);
    initHeaderView();
}

<span class="function"><span class="keyword">public</span> <span class="title">RefreshListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>{
    super(context, attrs, defStyle);
    initHeaderView();
}

<span class="comment">//下面就是将下拉的布局添加到ListView中</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHeaderView</span><span class="params">()</span> </span>{
    mHeaderView = View.inflate(getContext(), R.layout.refresh_header, null);
    <span class="comment">// 将下拉刷新的布局加到listView顶部</span>
    <span class="keyword">this</span>.addHeaderView(mHeaderView);
    tvTitle = (TextView) mHeaderView.findViewById(R.id.tv_title);
    tvTime = (TextView) mHeaderView.findViewById(R.id.tv_time);
    ivArrow = (ImageView) mHeaderView.findViewById(R.id.iv_arr);
    pbProgress = (ProgressBar) mHeaderView.findViewById(R.id.pb_progress);
    <span class="comment">// 下面两句代码就是将刷新显示的布局因隐藏</span>
    mHeaderView.measure(<span class="number">0</span>, <span class="number">0</span>);
    mHeaderViewHeight = mHeaderView.getMeasuredHeight();
    mHeaderView.setPadding(<span class="number">0</span>, -mHeaderViewHeight, <span class="number">0</span>, <span class="number">0</span>);
    initArrowAnim();
}

<span class="comment">/*
 * 初始化脚布局，就上拉加载的布局添加到ListView里面去
 */</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFooterView</span><span class="params">()</span> </span>{
    mFooterView = View.inflate(getContext(),
            R.layout.refresh_listview_footer, null);
    <span class="keyword">this</span>.addFooterView(mFooterView);

    mFooterView.measure(<span class="number">0</span>, <span class="number">0</span>);
    mFooterViewHeight = mFooterView.getMeasuredHeight();

    mFooterView.setPadding(<span class="number">0</span>, -mFooterViewHeight, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 隐藏</span>

    <span class="keyword">this</span>.setOnScrollListener(<span class="keyword">this</span>);
}


@<span class="function">Override
<span class="keyword">public</span> boolean <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>{
    <span class="keyword">switch</span> (ev.getAction()) {
    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:
        startY = (<span class="keyword">int</span>) ev.getRawY();
        <span class="keyword">break</span>;
    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:
        <span class="keyword">int</span> endY = (<span class="keyword">int</span>) ev.getRawY();
        <span class="keyword">if</span> (startY == -<span class="number">1</span>) {
            <span class="comment">// break;</span>
            startY = (<span class="keyword">int</span>) ev.getRawY();
        }

        <span class="keyword">if</span> (mCurrrentState == STATE_REFRESHING) {
            <span class="keyword">break</span>;
        }
        <span class="keyword">int</span> dy = endY - startY;<span class="comment">// 移动偏移量</span>
        <span class="keyword">if</span> (dy &gt; <span class="number">0</span> &amp;&amp; getFirstVisiblePosition() == <span class="number">0</span>) {
            <span class="keyword">int</span> padding = dy - mHeaderViewHeight;<span class="comment">// 计算padding</span>
            mHeaderView.setPadding(<span class="number">0</span>, padding, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 设置当前padding</span>
            <span class="keyword">if</span> (padding &lt; <span class="number">0</span> &amp;&amp; mCurrrentState != STATE_PULL_REFRESH) {
                mCurrrentState = STATE_PULL_REFRESH;
                refreshState();
            } <span class="keyword">else</span> <span class="keyword">if</span> (padding &gt; <span class="number">0</span>
                    &amp;&amp; mCurrrentState != STATE_RELEASE_REFRESH) {
                mCurrrentState = STATE_RELEASE_REFRESH;
                refreshState();
            }
            <span class="keyword">return</span> <span class="literal">true</span>;
        }
        <span class="keyword">break</span>;
    <span class="keyword">case</span> MotionEvent.ACTION_UP:
        <span class="comment">// mHeaderView.measure(0, 0);</span>
        startY = -<span class="number">1</span>;<span class="comment">// 重置</span>
        <span class="keyword">if</span> (mCurrrentState == STATE_PULL_REFRESH) {
            mHeaderView.setPadding(<span class="number">0</span>, -mHeaderViewHeight, <span class="number">0</span>, <span class="number">0</span>);
        } <span class="keyword">else</span> <span class="keyword">if</span> (mCurrrentState == STATE_RELEASE_REFRESH) {
            mCurrrentState = STATE_REFRESHING;
            mHeaderView.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
            refreshState();

        }
        <span class="keyword">break</span>;
    }
    <span class="keyword">return</span> super.onTouchEvent(ev);
}

<span class="comment">/*
 * 刷新下拉控件的布局
 */</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshState</span><span class="params">()</span> </span>{
    <span class="keyword">switch</span> (mCurrrentState) {
    <span class="keyword">case</span> STATE_PULL_REFRESH:
        tvTitle.setText(<span class="string">"下拉刷新"</span>);
        ivArrow.setVisibility(View.VISIBLE);
        pbProgress.setVisibility(View.INVISIBLE);
        ivArrow.startAnimation(animDown);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> STATE_RELEASE_REFRESH:
        tvTitle.setText(<span class="string">"松开刷新"</span>);
        ivArrow.setVisibility(View.VISIBLE);
        pbProgress.setVisibility(View.INVISIBLE);
        ivArrow.startAnimation(animUp);
        <span class="keyword">break</span>;
    <span class="keyword">case</span> STATE_REFRESHING:
        tvTitle.setText(<span class="string">"正在刷新..."</span>);
        ivArrow.clearAnimation();<span class="comment">// 必须先清除动画,才能隐藏</span>
        ivArrow.setVisibility(View.INVISIBLE);
        pbProgress.setVisibility(View.VISIBLE);

        <span class="keyword">if</span> (listener != null) {
            listener.onRefresh();
        }
        <span class="keyword">break</span>;
    }
}

<span class="comment">/**
 * 初始化箭头动画
 */</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initArrowAnim</span><span class="params">()</span> </span>{
    <span class="comment">// 箭头向上动画</span>
    animUp = <span class="keyword">new</span> RotateAnimation(<span class="number">0</span>, -<span class="number">180</span>, Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>,
            Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);
    animUp.setDuration(<span class="number">200</span>);
    animUp.setFillAfter(<span class="literal">true</span>);

    <span class="comment">// 箭头向下动画</span>
    animDown = <span class="keyword">new</span> RotateAnimation(-<span class="number">180</span>, <span class="number">0</span>, Animation.RELATIVE_TO_SELF,
            <span class="number">0.5f</span>, Animation.RELATIVE_TO_SELF, <span class="number">0.5f</span>);
    animDown.setDuration(<span class="number">200</span>);
    animDown.setFillAfter(<span class="literal">true</span>);

}

<span class="keyword">private</span> OnRefreshListener listener;

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnRefreshListener</span><span class="params">(OnRefreshListener listener)</span> </span>{
    <span class="keyword">this</span>.listener = listener;
}

<span class="comment">//给外部调用的监听接口</span>
<span class="keyword">public</span> interface OnRefreshListener {
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadMore</span><span class="params">()</span></span>;<span class="comment">// 加载下一页数据</span>
}

<span class="comment">/*
 * 收起下拉刷新及上垃加载的控件
 */</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefreshComplete</span><span class="params">(boolean success)</span> </span>{
    <span class="keyword">if</span> (isLoadingMore) {<span class="comment">// 正在加载更多...</span>
        mFooterView.setPadding(<span class="number">0</span>, -mFooterViewHeight, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 隐藏脚布局</span>
        isLoadingMore = <span class="literal">false</span>;
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> (mCurrrentState == STATE_REFRESHING) {
            mCurrrentState = STATE_PULL_REFRESH;
            tvTitle.setText(<span class="string">"下拉刷新"</span>);
            ivArrow.setVisibility(View.VISIBLE);
            pbProgress.setVisibility(View.INVISIBLE);
            mHeaderView.setPadding(<span class="number">0</span>, -mHeaderViewHeight, <span class="number">0</span>, <span class="number">0</span>);
            <span class="keyword">if</span> (success) {
                tvTime.setText(<span class="string">"最后刷新时间:"</span> + getCurrentTime());
            }
        }
    }
}

<span class="comment">/**
 * 获取当前时间
 */</span>
<span class="function"><span class="keyword">public</span> String <span class="title">getCurrentTime</span><span class="params">()</span> </span>{
    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);
    <span class="keyword">return</span> format.format(<span class="keyword">new</span> Date());
}

<span class="keyword">private</span> boolean isLoadingMore;

@<span class="function">Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span> </span>{
    <span class="keyword">if</span> (scrollState == SCROLL_STATE_IDLE
            || scrollState == SCROLL_STATE_FLING) {

        <span class="keyword">if</span> (getLastVisiblePosition() == getCount() - <span class="number">1</span> &amp;&amp; !isLoadingMore) {<span class="comment">// 滑动到最后</span>
            System.out.println(<span class="string">"到底了....."</span>);
            mFooterView.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 显示</span>
            setSelection(getCount() - <span class="number">1</span>);<span class="comment">// 改变listview显示位置</span>

            isLoadingMore = <span class="literal">true</span>;

            <span class="keyword">if</span> (listener != null) {
                listener.onLoadMore();
            }
        }
    }
}

@<span class="function">Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem,
        <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span> </span>{

}

OnItemClickListener mItemClickListener;

@<span class="function">Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnItemClickListener</span><span class="params">(
        android.widget.AdapterView.OnItemClickListener listener)</span> </span>{
    super.setOnItemClickListener(<span class="keyword">this</span>);

    mItemClickListener = listener;
}

@<span class="function">Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="keyword">int</span> position,
        <span class="keyword">long</span> id)</span> </span>{
    <span class="keyword">if</span> (mItemClickListener != null) {
        <span class="comment">//通过这样获得正确的id，不然的话我们得减去LiatView添加的头布局跟底布局</span>
        mItemClickListener.onItemClick(parent, view, position
                - getHeaderViewsCount(), id);
    }
}
}
</code></pre><p>　　这样我们就自己写好了一个实现了上拉加载跟下拉刷新的ListView。当然这里的ProgressBar控件可能有点丑，下面的代码可以给ProgressBar重新设置背景：</p>
<pre><code><span class="xml"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">rotate</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
<span class="attribute">android:fromDegrees</span>=<span class="value">"0"</span>
<span class="attribute">android:pivotX</span>=<span class="value">"50%"</span>
<span class="attribute">android:pivotY</span>=<span class="value">"50%"</span>
<span class="attribute">android:toDegrees</span>=<span class="value">"360"</span> &gt;</span>

<span class="tag">&lt;<span class="title">shape</span>
    &lt;!<span class="attribute">--</span>这个圆环半径是<span class="attribute">12dp--</span>&gt;</span>
    android:innerRadius="12dp"
    <span class="comment">&lt;!--生成一个圆环--&gt;</span>
    android:shape="ring"
    android:thickness="3dp"
    android:useLevel="false" &gt;
    <span class="tag">&lt;<span class="title">gradient</span>
        <span class="attribute">android:centerColor</span>=<span class="value">"#3f00"</span>
        <span class="attribute">android:endColor</span>=<span class="value">"#f00"</span>
        <span class="attribute">android:startColor</span>=<span class="value">"#fff"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">shape</span>&gt;</span></span>
</code></pre><p></p>
<p>　　这样一个不错的能实现下拉刷新跟上拉加载的ListView就实现了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　下拉刷新跟上拉加载这两个功能我相信在android开发中用的很多，毕竟这两个功能在增强用户体验，也解决了很多开发问题。但是我相信这两个功能的实现恐怕不好实现吧（针对很多新手来说），于是就有很多开源库比如<a href="https://github.com/chrisbanes/Android-PullToRefresh">Android-PullToRefresh</a>、谷歌自己推出的SwipeRefreshLayout等开源库。但是由于我认为自己造轮子对自己的技术提升比较好，因此我自己也写了一个针对listView的下拉刷新跟上拉加载。<br>]]>
    
    </summary>
    
      <category term="ListView下拉刷新跟上拉加载" scheme="http://yoursite.com/tags/ListView%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E8%B7%9F%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xutils3上传图片]]></title>
    <link href="http://yoursite.com/2015/11/27/xutils3/"/>
    <id>http://yoursite.com/2015/11/27/xutils3/</id>
    <published>2015-11-27T13:32:59.000Z</published>
    <updated>2015-11-28T06:03:08.856Z</updated>
    <content type="html"><![CDATA[<p>　　xutils是国内wyoufif大神写的一个牛逼的开源库，功能挺全面的（单图上传、批量上传（图片）文件、加载网路图片等）。但是xutils以前的版本是基于httpclient的，者本来对于android没什么影响的。但是谷歌偏偏在android6.0以后的版本删除了httpClient，这就让我们无法正确的使用xutils了，于是xutils的作者wyoufif在前不久对对xutils版本进行大量重构，从而推出xutils3.x版本。<a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="external">xutils3详情查看</a><br><a id="more"></a></p>
<h3 id="1、xutils3简介">1、xutils3简介</h3><p>　　xutils3是作者wyoufif为了适应android6.0而对推出的新的版本。由于xutils3是基于URLConnection的，因此改动比较大，而需要升级版本的可能有些麻烦。<a href="https://github.com/wyouflf/xUtils3" target="_blank" rel="external">详情查看</a>。由于我主要使用了上传文件模块，因此本篇文章我就主要介绍上传文件，其他模块有时间在介绍。</p>
<h3 id="2、xutils3上传单个文件（图片）">2、xutils3上传单个文件（图片）</h3><p>　　首先要使用xutils3的话，需要现在application里面进行初始化，否则会报<strong> 空指针异常 </strong>，初始化代码如下：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Application</span> {</span>
<span class="annotation">@Override</span>
public void onCreate() {
    <span class="keyword">super</span>.onCreate();
    <span class="comment">//初始化xutils3</span>
    x.<span class="type">Ext</span>.init(<span class="keyword">this</span>);
    x.<span class="type">Ext</span>.setDebug(<span class="literal">true</span>); <span class="comment">// 是否输出debug日志，这句代码可以不要</span>
    }
}
</code></pre><p>　　这样我们就能开始使用xutils3，下面就可以开始实现上传单个图片。其实在xutils3.x里面上传图片很简单，就是将通过路径找到文件，然后通过xutils3封装的类传递过去进行了。下面让我们来看单图上传关键代码：</p>
<pre><code><span class="comment">//这里的URLUtils.UPLOAD_IMG就是我们要访问的路径</span>
RequestParams <span class="keyword">params</span> = <span class="keyword">new</span> RequestParams(URLUtils.UPLOAD_IMG);
<span class="comment">//设为true就是以表单形式上传，否则上传原始文件流</span>
<span class="keyword">params</span>.setMultipart(<span class="keyword">true</span>);
<span class="comment">//下面就是请求网络时传递的参数</span>
<span class="comment">//params.addQueryStringParameter();</span>
<span class="keyword">params</span>.addBodyParameter(<span class="string">"photo"</span>, <span class="number">1</span> + <span class="string">""</span>);
<span class="keyword">params</span>.addBodyParameter(<span class="string">"uid"</span>, SharedPreferencesUtils.getString(ClipActivity.<span class="keyword">this</span>, <span class="string">"login_id"</span>));
<span class="comment">//这里的第一个字段是随便写的，第二个参数是要传递的图盘或者文件，第三个参数是这个图片或者文件的后缀名（由于图片有后缀名因此就传为空）</span>
<span class="keyword">params</span>.addBodyParameter(<span class="string">"file"</span>, <span class="keyword">new</span> File(path), <span class="keyword">null</span>);
</code></pre><h3 id="3、xutils3多图上传">3、xutils3多图上传</h3><p>　　在上面我们实现了单图上传，那么多图上传呢？就更简单了，再接再单图上传里面加个for循环就搞定。下面我们来看代码：</p>
<pre><code>RequestParams <span class="keyword">params</span> = <span class="keyword">new</span> RequestParams(URLUtils.TEST_PAGER_UPLOAD);
<span class="keyword">params</span>.setMultipart(<span class="keyword">true</span>);
<span class="keyword">params</span>.addQueryStringParameter(<span class="string">"uid"</span>, SharedPreferencesUtils.getString(context, <span class="string">"login_id"</span>));
<span class="keyword">params</span>.addQueryStringParameter(<span class="string">"tid"</span>, id);
<span class="keyword">params</span>.addQueryStringParameter(<span class="string">"title"</span>, <span class="string">"试卷111"</span>);
<span class="comment">//我这里限制的最多只能上传9张图片</span>
<span class="keyword">if</span> (num &lt; <span class="number">10</span>) {
<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) {
<span class="comment">//通过路径生成文件</span>
File file = <span class="keyword">new</span> File(Bimp.tempSelectBitmap.<span class="keyword">get</span>(i).getPath_absolute());
<span class="comment">//这里的第一个参数file是随便写的，第二个则是要上传的文件，第三个怎是文件的后缀名，当有后缀名时为空</span>
<span class="keyword">params</span>.addBodyParameter(<span class="string">"file"</span> + i, file, <span class="keyword">null</span>);
    }
}
</code></pre><h3 id="4、其他">4、其他</h3><p>　　上面的代码就是我们通过xutils3来实现的方法。当然我们只是将这些参数传递到RequestParams这个实体内，然后通过发送请求就可以了。当然我们还可以对xutils3进一步封装，具体请看我的另外一篇博客<a href="/2015/11/18/volley/">Volley框架的使用</a>。上面代码经过了我的测试的。当然如果有错误之处还请读者指出来，谢谢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　xutils是国内wyoufif大神写的一个牛逼的开源库，功能挺全面的（单图上传、批量上传（图片）文件、加载网路图片等）。但是xutils以前的版本是基于httpclient的，者本来对于android没什么影响的。但是谷歌偏偏在android6.0以后的版本删除了httpClient，这就让我们无法正确的使用xutils了，于是xutils的作者wyoufif在前不久对对xutils版本进行大量重构，从而推出xutils3.x版本。<a href="https://github.com/wyouflf/xUtils3">xutils3详情查看</a><br>]]>
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="xutils3" scheme="http://yoursite.com/tags/xutils3/"/>
    
      <category term="上传图片" scheme="http://yoursite.com/tags/%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Volley框架的使用]]></title>
    <link href="http://yoursite.com/2015/11/18/volley/"/>
    <id>http://yoursite.com/2015/11/18/volley/</id>
    <published>2015-11-18T15:35:28.000Z</published>
    <updated>2015-11-27T13:39:29.520Z</updated>
    <content type="html"><![CDATA[<p>　　Volley是谷歌在2013年IO大会上发布的能使网络通信更快，更简单，更健壮的android平台网络通信库，特别适合数据量不大但是通信频繁的场景。但是如果对于大数据（large payloads ），流媒体等就有些不实用，望读者能够正确的使用Volley.<br>　　<img src="http://7xo589.com1.z0.glb.clouddn.com/20130702124537953.png" alt=""><br><a id="more"></a></p>
<h3 id="1、Volley引入背景">1、Volley引入背景</h3><p>　　在android中，网络请求只有HttpURLConnection（Http协议）跟HTTPClient（Apache）两种最原生的请求方式。但是由于请求非常频繁且使用原始的方法进行网络请求非常麻烦，所有就有一些大神对这两种方式进行了封装，从而诞生可一些如xutils（xutils3支持6.0）、okHttp、AsyncHttpClient等一些开源库。但是这些开源库有一定的局限性并且包含的东西比较多（我个人观点）所有在网络请求频繁的应用场景就不是很好的适应，并且健壮性稍差一点。因此谷歌就在2013年IO大会上推出Volley开源库（由于是官方推出的，所有我就喜欢用Volley）来更好、更快的来实现网络请求。</p>
<h3 id="2、Volley功能简介">2、Volley功能简介</h3><p>　　简单的来讲，Volley提供了如下功能：</p>
<blockquote>
<p>封装了的异步的RESTful 请求API；<br>一个优雅和稳健的请求队列；<br>一个可扩展的架构，它使开发人员能够实现自定义的请求和响应处理机制；<br>能够使用外部HTTP Client库；<br>缓存策略；<br>自定义的网络图像加载视图（NetworkImageView，ImageLoader等)；</p>
</blockquote>
<p>　　由于我使用Volley最多是进行网络请求获取数据，因此此篇博客也主要是讲Volley通过get或者post从服务器上获取数据。那么首先讲通过post来从服务器上获取数据</p>
<h3 id="3、Volley请求队列的创建">3、Volley请求队列的创建</h3><p>　　由于Volley的所有请求都放在一个队列，然后进行处理。因此我们就需要创建一个消息队列（理论上这个消息队列是在任何地方都可以创建的，但是建议在application里面创建），代码如下：</p>
<pre><code>equestQueue mRequestQueue = Volley.newRequestQueue(<span class="keyword">this</span>); <span class="regexp">//</span> <span class="string">'this'</span> <span class="keyword">is</span> Context
</code></pre><p>　　如果在application里面的话：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Application</span> {</span>

<span class="comment">// 请求网络队列</span>
<span class="keyword">private</span> static <span class="type">RequestQueue</span> requestQueue;

<span class="annotation">@Override</span>
public void onCreate() {
    <span class="keyword">super</span>.onCreate();
    requestQueue = <span class="type">Volley</span>.newRequestQueue(getApplicationContext());
}

public static <span class="type">RequestQueue</span> getHttpVolley() {
    <span class="keyword">return</span> requestQueue;
}
</code></pre><p>　　这样我们就把Volley的请求队列创建好了。</p>
<h3 id="4、Volley网络请求">4、Volley网络请求</h3><p>　　下面我们就可以进行网络请求数据啦，首先我们先来看post请求来进行网络请求的代码（至于为什么是先看post，是因为post相对于get请求只是稍微难一点）：</p>
<pre><code>StringRequest stringRequest = <span class="literal">new</span> StringRequest(Request<span class="built_in">.</span>Method<span class="built_in">.</span>POST,httpurl,
<span class="literal">new</span> Response<span class="built_in">.</span>Listener&lt;<span class="built_in">String</span>&gt;() {
    @Override
    <span class="keyword">public</span> <span class="literal">void</span> onResponse(<span class="built_in">String</span> response) {
        <span class="keyword">Log</span><span class="built_in">.</span>d(<span class="built_in">TAG</span>, <span class="string">"response -&gt; "</span> + response);
    }
}, <span class="literal">new</span> Response<span class="built_in">.</span>ErrorListener() {
    @Override
    <span class="keyword">public</span> <span class="literal">void</span> onErrorResponse(VolleyErr<span class="subst">or</span> err<span class="subst">or</span>) {
        <span class="keyword">Log</span><span class="built_in">.</span>e(<span class="built_in">TAG</span>, err<span class="subst">or</span><span class="built_in">.</span>getMessage(), err<span class="subst">or</span>);
    }
}) {

@Override
<span class="keyword">protected</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; getParams() {
    <span class="comment">//在这里设置需要post的参数</span>
          <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();  
        <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"name1"</span>, <span class="string">"value1"</span>);  
        <span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"name2"</span>, <span class="string">"value2"</span>);  
      <span class="keyword">return</span> <span class="keyword">params</span>;
}
<span class="comment">//将当前请求进行标记，方便管理</span>
stringRequest<span class="built_in">.</span>setTag(<span class="built_in">tag</span>);
<span class="comment">//将stringRequest添加到Volley的请求队列</span>
requestQueue<span class="built_in">.</span>add(stringRequest);
<span class="comment">//开始进行网络请求</span>
requestQueue<span class="built_in">.</span>start();
</code></pre><p>　　这样我们就能从服务器上请求到数据了。那我就先来解释一下代码。这里的<strong> StringRequest </strong>类是表示服务器返回的数据是String类型。而如果服务器返回的数据是Json对象或者json数组的话，用<strong> StringRequest </strong>则稍稍麻烦。因此Volley就给我们提供了直接返回json对象或者数据的方法，如下：</p>
<blockquote>
<p>JsonObjectRequest：返回JSON对象。<br>JsonArrayRequest：返回JsonArray。<br>StringRequest：返回String，这样可以自己处理数据，更加灵活。<br>如果返回的数据不是这三种的话我们也可以继承Request<t>自定义Request</t></p>
</blockquote>
<p>　　这样我们就可以根据后台返回的数据来采用相应的办法来解析，然后<strong> onResponse </strong>方法里面的就是当请求成功时，调用的方法。<strong> onErrorResponse </strong>则是请求失败时，调用的方法。<strong> getParams </strong>这是用post请求时需要上传的数据（以map集合的形式上传，当然也可以用ArrayMap集合）。剩下的代码已有注释就不解释啦。<br>　　上面我讲解了Volley通过post来请求数据，那么如何通过get方式来请求数据啊？这就更简单咯，直接去掉上面代码里面的getParams方法就行了。通过上述讲解我想读者都知道了Volley如何通过get或者post来请求网络了吧。</p>
<h3 id="5、Volley的封装">5、Volley的封装</h3><p>　　通过上面的代码我们就能通过Volley进行网络请求啦，但是网络访问请求过多时，我们会发现会有许多相同的代码。这样的话就需要我们来对Volley进行进一步的封装了。那么如何进行封装呢？首先我们创建一个名为<strong> VolleyInterface </strong>的抽象类，代码如下：</p>
<pre><code><span class="comment">/**
* 在这里方便对网络请求的管理，如
* 
* <span class="doctag">@author</span> Administrator
* 
*/</span>
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VolleyInterface</span> </span>{
<span class="keyword">private</span> Context context;
<span class="keyword">public</span> <span class="keyword">static</span> Listener&lt;String&gt; mListener;
<span class="keyword">public</span> <span class="keyword">static</span> ErrorListener mErrorListener;

<span class="function"><span class="keyword">public</span> <span class="title">VolleyInterface</span><span class="params">(Context context, Listener&lt;String&gt; Listener,
        ErrorListener ErrorListener)</span> </span>{
    <span class="keyword">this</span>.context = context;
    VolleyInterface.mListener = Listener;
    VolleyInterface.mErrorListener = ErrorListener;

}

<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">onMySuccess</span><span class="params">(<span class="keyword">int</span> what, String response)</span></span>;

<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">onMyError</span><span class="params">(<span class="keyword">int</span> what, VolleyError <span class="keyword">error</span>)</span></span>;

<span class="keyword">public</span> Listener&lt;String&gt; loadingListener(<span class="keyword">final</span> <span class="keyword">int</span> what) {
    mListener = <span class="keyword">new</span> Listener&lt;String&gt;() {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>{
            onMySuccess(what, response);
        }
    };
    <span class="keyword">return</span> mListener;
}

<span class="keyword">public</span> <span class="function">ErrorListener <span class="title">errorListener</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> what)</span> </span>{
    mErrorListener = <span class="keyword">new</span> ErrorListener() {

        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError <span class="keyword">error</span>)</span> </span>{
            onMyError(what, <span class="keyword">error</span>);
        }
    };
    <span class="keyword">return</span> mErrorListener;

}
}
</code></pre><p>　　这样我们就对Volley里面的请求成功或者失败的方法进行了一次抽取。这样我们就可以省掉一些代码了，但是如果细心的读者会发现，Volley发送请求时的代码也相同，我们是不是也可以封装啊？当然是可以的，我们首先建一个<strong> HttpUtils </strong>的工具类，然后在这个类里面写上如下代码：</p>
<pre><code><span class="keyword">private</span> StringRequest stringRequest;
<span class="keyword">public</span> <span class="literal">void</span> postVolley(int what, Context context, <span class="built_in">String</span> url, <span class="built_in">String</span> <span class="built_in">tag</span>,
        final <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="keyword">Params</span>, VolleyInterface vif) {
    MyApplication<span class="built_in">.</span>getHttpVolley()<span class="built_in">.</span>cancelAll(<span class="built_in">tag</span>);
    stringRequest = <span class="literal">new</span> StringRequest(Method<span class="built_in">.</span>POST, url,
            vif<span class="built_in">.</span>loadingListener(what), vif<span class="built_in">.</span>errorListener(what)) {
        @Override
        <span class="keyword">protected</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; getParams() throws AuthFailureErr<span class="subst">or</span> {
            <span class="keyword">return</span> <span class="keyword">Params</span>;
        }
    };
    stringRequest<span class="built_in">.</span>setTag(<span class="built_in">tag</span>);
    MyApplication<span class="built_in">.</span>getHttpVolley()<span class="built_in">.</span>add(stringRequest);
    MyApplication<span class="built_in">.</span>getHttpVolley()<span class="built_in">.</span>start();

}
</code></pre><p>　　通过上面两段代码，我们就对Volley封装好了，然后就是在需要进行网络请求的页面<strong> new </strong>一个VolletInterface对象，然后在需要进行网络请求的地方调用<strong> HttpUtils </strong>的postVolley方法就行了，这样我们对Volley的封装就完成了。是不是很简单啊，嘻嘻…</p>
<h3 id="6、注意事项">6、注意事项</h3><p>　　通过上面的代码我相信读者就能够运用Volley啦，但是在实际应用中还是有以下几点注意事项：</p>
<blockquote>
<p>1、post请求时，我们传递的参数的值不能为空否则会报空指针异常。<br>2、同时进行多次网络请求时，tag的值不能一样，否则只会执行最后的一次网络请求。<br>3、由于Volley可以与Activity的生命周期进行关联（这也是我喜欢Volley的原因），因此建议在跳转页面时，调用<code>MyApplication.getHttpVolley().cancelAll(tag);</code>取消标记为tag的网络请求。</p>
</blockquote>
<h3 id="7、其他">7、其他</h3><p>　　由于本人技术有限，因此我就只能讲解Volley通过post或者get来请求网络数据部分。也由于我写博客时间很短，写的不好的地方或者出现的问题希望读者能给我提出来，以便我更新，谢谢</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　Volley是谷歌在2013年IO大会上发布的能使网络通信更快，更简单，更健壮的android平台网络通信库，特别适合数据量不大但是通信频繁的场景。但是如果对于大数据（large payloads ），流媒体等就有些不实用，望读者能够正确的使用Volley.<br>　　<img src="http://7xo589.com1.z0.glb.clouddn.com/20130702124537953.png" alt=""><br>]]>
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="volley" scheme="http://yoursite.com/tags/volley/"/>
    
      <category term="网络请求" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo静态博客搭建教程]]></title>
    <link href="http://yoursite.com/2015/11/04/hexo/"/>
    <id>http://yoursite.com/2015/11/04/hexo/</id>
    <published>2015-11-04T15:29:44.000Z</published>
    <updated>2015-11-14T13:44:27.812Z</updated>
    <content type="html"><![CDATA[<p>　　经过接近一周的时间总算搭好属于自己的一个静态博客（可以拿来装逼，哈哈）。由于我搭建的过程中遇到了很多问题（在这里我要感谢流云跟默然两位网友的帮助），因此我就打算将自己的搭建过程分享出来，希望能帮到更多的读者（如果读者看了我的分享还没懂得话就请多百度或者给我留言）。<br><a id="more"></a></p>
<h3 id="1-下载node-js">1.下载node.js</h3><p>　　<a href="https://www.nodejs.org" target="_blank" rel="external">点击下载</a>，下载完毕直接安装即可（如果不会安装请自行百度）</p>
<h3 id="2-下载git">2.下载git</h3><p>　　这个直接百度git就可以了，网上多多（也可以在电脑管家之类的软件里面下载），下载完毕后直接安装即可。<br>　　我想上面两部作为一个程序员都是必须要求会的，如果不会的话……</p>
<h3 id="3-安装hexo">3.安装hexo</h3><p>　　下载好git以后，点击Git下的<strong> Git Bash </strong>选项，会弹出一个输入命令行的框。首先输入<strong> npm </strong>命令即可安装。然后再输入下面的两句命令行即可安装hexo完成：<br>　　<code>1、npm install hexo-cli -g</code><br>　　<code>2、npm install hexo --save</code></p>
<h3 id="4-初始化hexo">4.初始化hexo</h3><p>　　hexo安装完成后，然后就在自己电脑上新建一个文件夹（任何地方都可以）.然后鼠标右键点击新建的文件夹选择<strong> Git Bash </strong>选项然后弹出一个命令行输入框。输入下面命令行进行初始化：<br>　　<code>hexo init</code><br>　　初始化完成后会在该文件夹下生成一些列文件及文件夹（如果没有生成就代表初始化失败，具体哪些文件夹请自行百度）。<br>　　正确的生成文件夹后可以执行下面的命令行：<br>　　<code>hexo server(hexo s)</code><br>　　如果打印出下面命令行则代表运行成功，则可以在浏览器上输入<code>localhost:4000(默认端口号是4000)</code>查看默认的博客效果。<br>　　<code>hexo is running at http://0.0.0.0:4000/.</code></p>
<h3 id="5-注册github账号">5.注册github账号</h3><p>　　<a href="https://github.com/" target="_blank" rel="external">点击即可注册</a>，<strong> 注意: </strong>虽然是英文但是还是可以注册的啊。<br>　　注册成功后耐心等待10分钟左右审核时间。审核过后直接点击主页面的右下角<code>new repository</code>，创建时的name必须与用户名一致。<strong> 如lmh18841113.github.io </strong><br>　　成功后则可访问建立的静态主页了</p>
<h3 id="6-关联本地git跟远程github">6.关联本地git跟远程github</h3><p>　　至于如何让本地git跟远程github关联呢，我们采用的是SSH keys(不懂的自己去百度哈，其实这个也不需要我们懂).<br>　　那么我们如何生成SSH keys呢？我们还是打开<strong> Git Bash </strong>，然后输入：<code>ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</code>则可。<br>　　然后后面都直接选择默认（点回车就行，当然输入密码时得输入）。<strong> 注意: </strong>其实这里面可以自己选择公钥跟私钥时，我们是可以选择放在自己定义的文件夹下面。<br>　　当出现下面图片里面的命令行时则代表公钥跟私钥生成成功。<br>　　<img src="http://7xo589.com1.z0.glb.clouddn.com/lpjsl.png" alt="">　　</p>
<h3 id="7-其他">7.其他</h3><p>　　找到hexo所在文件夹，进入<strong> \source_posts </strong>到文件夹下，直接打开后缀名为.md的文件进行编辑即可（这里建议用到markdown）<br>　　由于hexo默认的主题比较丑，所有我们希望主题能好看、炫酷。所有需要我们更改主题。<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">点击更换</a>。我目前使用的主题是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">yilia</a>这位大神的所写的主题。在这里我谢谢<strong>yilia</strong>大神。<br>　　博客写完后则通过<code>hexo g</code>保存到本地，然后通过<code>hexo d</code>上传到github，然后通过github给的链接就可以访问。<strong>在这里需要注意下面几点：</strong><br>　　再向github上传时，得需要该电脑开启ssh端口（对于window来说，只有mac跟linux我就不知道了哈）。否则不会上传成功（我也没解决这个问题）。但是我用了github for window这个来上传的。可以去<a href="http://github-for-windows.en.softonic.com/" target="_blank" rel="external">github for window</a>官网下载，但是安装时需要翻墙才行。因此我又在网上找到<strong>雅然风懿</strong>分享的<a href="http://download.csdn.net/download/lyg468088/8723039?ticket=ST-65736-fzVh72OVuj7WUwM2c9w0-passport.csdn.net" target="_blank" rel="external">github for window离线安装包</a>。在这里我感谢网友雅然风懿的分享。<br>　　由于这是我第一次写博客，写的不好的地方请大家多多指教哈。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　经过接近一周的时间总算搭好属于自己的一个静态博客（可以拿来装逼，哈哈）。由于我搭建的过程中遇到了很多问题（在这里我要感谢流云跟默然两位网友的帮助），因此我就打算将自己的搭建过程分享出来，希望能帮到更多的读者（如果读者看了我的分享还没懂得话就请多百度或者给我留言）。<br>]]>
    
    </summary>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>